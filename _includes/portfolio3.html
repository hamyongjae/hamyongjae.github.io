<link href="https://fonts.googleapis.com/css?family=Nanum+Gothic" rel="stylesheet">

<div style="text-align: left; margin-left: 80px; margin-right: 80px;">

    <h1 style="text-align: center"><strong>블루투스와 Wifi무선통신을 이용한 Smart button</strong></h1><br><br><br>

    <h2><strong>서론</strong></h2><br>

    <h4>본 연구에서는 일상생활에서 불편함을 느낄 법한 여러가지 상황을 떠올려 봤을 때 불편함을 가장 많이 해소할 수 있고, 실현 가능성 있는 기능을 제어할 수 있도록 구현하였다, 버튼을 누르면 블루투스
        무선통신을 통해 휴대폰 조명이 ON/OFF 되거나, 비상전화가 걸리거나, 음악이 ON/OFF 되는 기능을 구현하였고, 뿐만 아니라, 스마트 플러그를 별도로 제작하여 휴대폰을 통해 콘센트에서 사용되는
        전기를 제어할 수 있는 기능을 구현함으로써, 사람이 직접 움직이지 않고, 원격제어를 통해 불필요한 움직임을 줄일 수 있는 디바이스 제작을 목표로 하였다. 본 논문에서는 안드로이드 플랫폼을 기반으로
        자바언어를 이용해 어플리케이션을 만들어 구현하였고, 스마트버튼 디바이스는 아두이노(Arduino)를 활용해 버튼의 모형과 회로도를 구성하였고 플러그의 디바이스는 실제 가정용 플러그(220V)를 구매해
        재조립하여 제작하였다.</h4><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_1.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진1] 작품 구상도</strong></h4><br><br>

    <h4>본 프로젝트에서는 ESP8266 모듈과 TCP/IP 소켓 통신을 이용하여 소형경량 데이터 전송장치를 설계하였다. 본 장치는 Wifi연결 기능을 지원하는 Esp8266모듈을 사용하여 서버와 클라이언트를
        구성하고, TCP/IP의 소켓 통신을 사용하여 양방향 데이터 전송을 지원하도록 구성하였다. 네트워크는 홈 네트워크와 같이 공유기를 중심으로 사설 IP를 부여하여 Esp8266이 각각 독립적인 IP를
        가지게 설계하였다. 본 장치는 양방향으로 데이터를 전송 할 수 있고, 서버 측에서 각각의 클라이언트 데이터들을 저장할 수 있다.</h4><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_2.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진2] Pin diagram of ESP8266</strong></h4><br>

    <h4>Esp8266은 내부는 Tensilica의 L106 Diamond 시리즈 32-bit 프로세스와 SRAM을 탑재하여 보다 저전력에서 고성능 동작이 가능하다. 센서와 같은 외부적인 데이터 를
        GPIO(General Purpose Input/Output)를 통해 제공 받 고, 아날로그 데이터도 1 채널 받을 수 있다. 또한 내부 Flash memory에 특정 펌웨어를 업로드 하여 보다 쉬운
        MCU(Micro Controller Unit) 컨트롤이 가능하다.
        ESP 8266 모듈을 선택한 이유는 Wifi soft ap동작, Wifi direct 연결 TCP/IP로 데이터 전송 지원을 하기 위해서다. Serial로 아두이노와 연결한 다음 아두이노에서 AT
        command를 전송해서 모듈을 제어 가능하다. Wifi 모듈의 baudrate(전송속도)가 115200으로 설정되어 있는데 SoftwareSerial라이브러리가 지원하는 최대 baudrate는
        19200 이기 때문에 SoftwareSerial 로 제어할 경우 문제가 생겼다. 따라서 아두이노 0번 1번 핀을 이용해 Hardware serial로 제어해야 한다. 일반적인 아두이노 보드에는
        Hardware serial 을 하나만 제공하기 때문에 0, 1번 핀을 사용하는 경우 PC로 Debug 데이터를 출력할 수가 없기 때문에 별도의 회로를 구성하였다.</h4><br>


    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_3.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진3] ESP 8266 회로도</strong></h4><br>

    <pre style="display: inline-block; border:1px solid #0000002e;"><code>
        #include &lt;ESP8266WiFi.h&gt;

            const char *ssid = "your_ssid";
            const char *password = "your_pass";
        
        
        
            void WiFiEvent(WiFiEvent_t event) {
                Serial.printf("[WiFi-event] event: %d\n", event);  
        
        
                switch(event) {
                    case WIFI_EVENT_STAMODE_GOT_IP:
                        Serial.println("WiFi connected");
                        Serial.println("IP address: ");
                        Serial.println(WiFi.localIP());
                        break;
                    case WIFI_EVENT_STAMODE_DISCONNECTED:
                        Serial.println("WiFi lost connection");  
                        break;
                }
            }
        
        
            void setup() {
                Serial.begin(115200);
            
                // delete old config
                WiFi.disconnect(true);
        
                delay(1000);
                WiFi.onEvent(WiFiEvent);
            
                WiFi.begin(ssid, password);
            
                Serial.println();
                Serial.println();
                Serial.println("Wait for WiFi... ");
            }
            
        
            
        
            void loop() {
                delay(1000);
            }

        </code>
        </pre><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_4.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진4] 안드로이드 신호 전송방식</strong></h4><br>

    <h4>아두이노에서 Wifi를 사용하기 위한 ESP8266 모듈을 적합한 핀번호에 연결하였다. 이와 같이 아두이노와 안드로이드 간에 TCP/IP 통신을 위한 환경을 조성했다. 이제 안드로이드에서 각각의
        기능을 위한 신호 전송을 해야하는데 각각의 신호를 받고 실행할 기능을 구별하기 위해 클릭, 롱 프레스, 더블 클릭으로 3가지 신호를 각각 구별하였다. 클릭을 한번 짧게 누르게 되면 특정 번호로 전화가
        걸리고, 버튼을 길게 꾸욱 누르면 조명이 ON/OFF 되고, 버튼을 더블 클릭하게 되면 음악이 ON/OFF가 되는 기능을 각각 구현하였다. 위와 같은 신호를 구별하기 위해 아두이노에서 전송하는 신호를
        안드로이드에 받을 때 1,2,3번으로 나누어서 각각의 기능을 구별하였다.</h4><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_5.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진5] 안드로이드 레이아웃</strong></h4><br>

    <h4>[사진5]에서 볼 수 있듯이 Set sever 버튼을 통해 서버가 열리게 되면 아두이노에서 미리 설정된 IP와 포트번호로 접속을 하게 된다. 접속을 함으로써 아두이노 스케치에서 셋팅된 각각의 방법으로
        신호를 구별하여 call, music, flash on/off 기능을 수행할 수 있다. 레이아웃 자체에서도 별도의 버튼을 추가 하여서 사용자에게 좀 더 편리한 접근성을 제공할 수 있다. 연결
        종료시에는 close sever 버튼을 누르면 연결이 종료되었다는 Toast 메시지메세 함께 연결이 끝나는 것을 확인할 수 있다.</h4><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_6.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진6] HC - 06</strong></h4><br>

    <h4>
        [사진6]는 HC-06 블루투스 모듈의 핀이다. 총 4개의 핀이 있으며 위에서부터 신호를 받기위한 핀인 RX 핀, 신호를 전송하기 위한 TX핀, GND(Ground), VCC 핀이 있다. 모듈의
        전원은 3.6V ~ 6V 사이에서 동작하므로 VCC핀은 아두이노의 5V 단자에 연결하면 된다. 모듈에 따라 3.3V에서 동작하는 모듈도 있으므로 규격을 꼭 확인하여 전원을 연결해야 한다. 본
        논문에서는 5V로 사용할 수 있는 HC-06 시리얼 모듈을 사용하였다.
        HC-06 의 옵션 값들은 시리얼로 연결하여 문자열로 직접 값들을 날리는 방법으로 설정하였다. 그리고, 시리얼 포트는 하나밖에 없기 때문에 아두이노 IDE 시리얼 모니터의 커맨드 창으로 명령어를 주기
        위하여 디지털 I/O 핀을 이용한 소프트웨어 시리얼을 사용했다.<br>
    </h4>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_7.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진7] HC - 06[그림10] HC-06 옵션값을 설정하기 위한 명령어</strong></h4><br>

    <pre style="display: inline-block; border:1px solid #0000002e;"><code>
    
#include &lt;SoftwareSerial.h&gt; 

#define rxPin 2 
#define txPin 3 
SoftwareSerial SwSerial(txPin, rxPin);
char data;

void setup() {
    Serial.begin(9600);
    SwSerial.begin(9600);
    Serial.println("Ready..");
    } 
void loop() {
Serial.flush();
Serial.print("cmd : ");
while(!Serial.available());
    // HC-06 으로 명령어를 날린다.
while(Serial.available()) {
data = Serial.read();
if(data == -1) break;
SwSerial.print(data);
Serial.print(data);
delay(1);
}
    Serial.println(); 
// HC-06에서 처리할 시간을 준다. 
delay(1000); 
Serial.print("return : "); 
// HC-06 으로 부터 받아온 리턴 값을 출력한다. 
while(SwSerial.available()) {
data = SwSerial.read();
if(data == -1) break;
Serial.print(data);
delay(1);
}
Serial.print("\n\n"); }
}
    </code></pre><br>
    <h4><strong></strong>[사진8] 시리얼모니터를 통해 옵션값을 HC-06으로 전송하는 스케치 코드</strong></h4><br>

    <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_8.jpg" style="max-width: 100%; height: auto;"><br>
    <h4><strong>[사진8] HC-06 옵션값을 설정하기 위한 회로도</strong>
        <h4><br>

            <h4>
                위 회로대로 연결해도 문제가 없는 모듈을 사용했다. SoftwareSerial 을 사용했기 때문에 0번과 1번 핀이 아닌 2번과 3번 핀에 연결하였다. 본 논문에서는 5v 전용으로
                간편하게 사용할 수 있는 블루투스 모듈을 사용했다. 이 와 같은 상황이 아닌 경우는 그에 맞게 잘 연결해야 한다.
            </h4>

            <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_9.jpg" style="max-width: 100%; height: auto;"><br>
            <h4><strong>[사진9] AT 커멘드 옵션 변경 결과 </strong></h4><br>

            <pre style="display: inline-block; border:1px solid #0000002e;"><code>
    
import android.bluetooth.BluetoothAdapter;
import android.content.Intent; 
import android.os.Bundle; 
import ketai.net.bluetooth.*; 
import ketai.ui.*;
import ketai.net.*; 
import controlP5.*;

KetaiBluetooth bt;  
KetaiList klist;
ControlP5 cp5;

void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
bt = new KetaiBluetooth(this);
}

void onActivityResult(int requestCode, int resultCode, Intent data) {
bt.onActivityResult(requestCode, resultCode, data);
}

//*******************************************************
//*******************************************************
PFont fontMy; //declaring font
boolean bReleased = true;   //no permament sending when finger boolean isConfiguring = true;
String info = "";
ArrayList devicesDiscovered = new ArrayList(); 
//store in array the discovered device

float resolutionRatio = 0.3;
int width = int(480 * resolutionRatio);
int height = int(800 * resolutionRatio);

int myColor = color(255);
int c1,c2;
float n,n1;
boolean flag = false;

void setup(){
//android screen setup
size(displayWidth, displayHeight);
width = displayWidth;
height = displayHeight;
orientation(PORTRAIT);
bt.start();//블루투스 시작!
frameRate(20);//프레임 수치
isConfiguring = true;
//버튼을 생성합니다.
cp5 = new ControlP5(this);

cp5.addButton("buttonA")
    .setSwitch(true)
    .setPosition(width/2-63,height/2-79)
    .setImages(loadImage("on.png"), loadImage("on.png"), loadImage("off.png"))//버튼이미지
    .updateSize();
}//setup

void draw() {
    if (isConfiguring){
ArrayList names;
//create the BtSerial object that will handle the connectio 
//블루투스 장비목록가져오기기
klist = new KetaiList(this, bt.getPairedDeviceNames()); 
isConfiguring = false; //stop selecting device
}
//color change
background(myColor);
myColor = lerpColor(c1,c2,n);
n += (1-n)* 0.1; 
}
//button Event Method
public void controlEvent(ControlEvent theEvent) {
println(theEvent.getController().getName());
n = 0;  
}

public void buttonA(int theValue) {
if(flag){
    String data = "o";
    bt.broadcast(data.getBytes());
c1 = c2;
    c2 = color(200,160,100);
    flag = false;
    println(" ON ---------->a button event from buttonA: "+theValue);
}else{
    c1 = c2;
    c2 = color(40,30,60);
    String data = "f";
    bt.broadcast(data.getBytes());
flag = true;
    println(" OFF ---------->a button event from buttonA: "+theValue);
}
}//buttonA


void onKetaiListSelection(KetaiList klist)
{
String selection = klist.getSelection(); //select the device to connect
bt.connectToDeviceByName(selection); //connect to the device 
klist = null; //dispose of bluetooth list for now
}

//Call back method to manage data received
void onBluetoothDataEvent(String who, byte[] data)
{
if (isConfiguring){
return;
}
//received
info += new String(data);
if(info.length() > 150)  //clean the words on screen if string to long
info = "";
}//END of Android processing coding

</code></pre><br>

            <h4>
                기본적으로 안드로이드 라이브러리를 추가하고 블루투스를 쓰기위해 Ketai, 버튼등의 UI를 쓰기위해 controlP5라는 라이브러리를 사용했다.
            </h4>

            <pre style="display: inline-block; border:1px solid #0000002e;"><code>

char incomingByte = 0;
boolean ledStat = false;
int relay_pin = 13; 
    
void setup() {
    Serial.begin(9600);
    pinMode(relay_pin,OUTPUT);
}
    
void loop() {
        if (Serial.available() > 0) {
            // read the incoming byte:
            incomingByte = Serial.read();
            if(incomingByte == 'f'){
            digitalWrite(relay_pin,LOW);
            Serial.println("turn off!!");
            Serial.print(incomingByte);
            Serial.println("<---------incomingByte");
            ledStat=false;       
            }else if(incomingByte == 'o'){
            digitalWrite(relay_pin,HIGH);
            Serial.println("turn on!!");
            Serial.print(incomingByte);
            Serial.println("<---------incomingByte");
            ledStat=true;
            }else{
            Serial.print("Error!");
            Serial.print(incomingByte);
            Serial.println("<---------incomingByte");
            }
        }
}
    </code></pre><br>
            <h4><strong>[사진10] 아두이노 프로그래밍 코드</strong></h4>

            <h4>
                이번 연구에서 블루투스 모듈의 목적은 시리얼 모듈로 들어오는 데이터를 그대로 읽어주는 모델이다. 따라서 코드도 단순하게 읽어들인 데이터를 incomingByte에저장하고 어떤 문자인지
                확인해 ‘o’이면
                릴레이를 키고 ‘f’이면 릴레이를 끄는 구조이다.
                한가지 주의를 해야될 점은 아두이노를 통해 시리얼포트로 다양한 형태의 데이터가 입출력 되지만 시리얼모니터는 ASCII형태의 Data를표현한다는점이다. 따라서 incomingByte
                변수를 char로 설정하고
                안드로이드 앱에서 보내는 데이터 형태를 char형태로 보낼 수 있다면 시리얼모니터창을 통해 DATA를 확인하면서 작업할 수 있다.
            </h4>
            <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_10.jpg" style="max-width: 100%; height: auto;"><br>
            <h4><strong>[사진11] o, f 를 입력받은 시리얼 모니터</strong></h4>

            <pre><code>
Private void initialize() {
    Logs.d(TAG, "# Activity - initialize()");
    mService.setupService(mActivityHandler);
    
    // If BT is not on, request that it be enabled.
    // RetroWatchService.setupBT() will then be called during onActivityResult
    if(!mService.isBluetoothEnabled()) {
        Intent enableIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
        startActivityForResult(enableIntent, Constants.REQUEST_ENABLE_BT);
    }
    
    // Load activity reports and display
    if(mRefreshTimer != null) {
        mRefreshTimer.cancel();
    }
    
    // Use below timer if you want scheduled job
    //mRefreshTimer = new Timer();
    //mRefreshTimer.schedule(new RefreshTimerTask(), 5*1000);
}

private void finalizeActivity() {
    Logs.d(TAG, "# Activity - finalizeActivity()");
    
    if(!AppSettings.getBgService()) {
        doStopService();
    } else {
    }


    // Clean used resources
    RecycleUtils.recursiveRecycle(getWindow().getDecorView());
    System.gc();
}

/**
    * Launch the DeviceListActivity to see devices and do scan
    */
private void doScan() {
    Intent intent = new Intent(this, DeviceListActivity.class);
    startActivityForResult(intent, Constants.REQUEST_CONNECT_DEVICE);
}

/**
    * Ensure this device is discoverable by others
    */
private void ensureDiscoverable() {
    if (mService.getBluetoothScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
        Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);
        intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300);
        startActivity(intent);
    }
}


/*****************************************************
    *	Public classes
    ******************************************************/

/**
    * Receives result from external activity
    */
public void onActivityResult(int requestCode, int resultCode, Intent data) {
    Logs.d(TAG, "onActivityResult " + resultCode);
    
    switch(requestCode) {
    case Constants.REQUEST_CONNECT_DEVICE:
        // When DeviceListActivity returns with a device to connect
        if (resultCode == Activity.RESULT_OK) {
            // Get the device MAC address
            String address = data.getExtras().getString(DeviceListActivity.EXTRA_DEVICE_ADDRESS);
            // Attempt to connect to the device
            if(address != null && mService != null)
                mService.connectDevice(address);
        }
        break;
        
    case Constants.REQUEST_ENABLE_BT:
        // When the request to enable Bluetooth returns
        if (resultCode == Activity.RESULT_OK) {
            // Bluetooth is now enabled, so set up a BT session
            mService.setupBT();
        } else {
            // User did not enable Bluetooth or an error occured
            Logs.e(TAG, "BT is not enabled");
            Toast.makeText(this, R.string.bt_not_enabled_leaving, Toast.LENGTH_SHORT).show();
        }
        break;
    }	// End of switch(requestCode)
}
    </code></pre>
            <h4><strong>[사진12] 안드로이드 블루투스 페어링 핵심코드</strong></h4>

            <h4>
                안드로이드에서 블루투스 페어링을 하기 위한 코드의 일부분이다. 본 기기가 블루투스 가능모드인지 확인하고 페어링할 상대 디바이스를 찾는다. 상대 디바이스를 찾게 되고 페어링이 수락이 되면
                블루투스 통신으로
                양방향 데이터 전송이 가능해진다. 만약 본 안드로이드 기기가 스스로 블루투스 모드가 아니면 블루투스 연결은 불가능하다. 만약 페어링이 된 상태가 되면 Toast message로
                연결되었음을 알리게 되고,
                반대로 연결이 해제가 된 경우도 Toast message 출력을 통해 사용자에게 알려줄 수 있다.
            </h4>

            <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_11.jpg" style="max-width: 100%; height: auto;"><br>
            <h4><strong>[사진13] 페어링 리스트</strong></h4>

            <h4>
                [사진13]에서 볼 수 있듯이 페어링을 하기 위해 상대방 기기 목록을 선택할 수 있다. 각각의 연결장치의 이름을 직접 설정하여 사용자가 원하는 이름을 부여 할 수 있고, 이름을 부여
                받은 하나의 객체가
                블루투스 기능을 켜게되면 스마트폰 어플리케이션 내에서 선택할 수 있는 목록에 나타나게 된다. 만약 블루투스모드가 켜져 있지 않은 상태로 페어링 목록을 검색하게 되면 화면에 나타나지 않아
                페어링은 불가능하다.
            </h4>

            <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_12.jpg" style="max-width: 100%; height: auto;"><br>
            <h4><strong>[사진14] AC 릴레이 내부적 구조</strong></h4>

            <h4>
                아두이노의 작은 전압(5V)으로 큰 전압(110~220V)을 제어 할 수 있는 릴레이가 필요했다. [그림9]와 같이 아두이노의 Output Signal을 AC 릴레이의 Input
                signal 부분에
                연결해주고 가정용 멀티탭을 개조해 AC릴레이와 연결해주면 아두이노의 5V의 전압이 INPUT에 작용할 때마다 접점이 이동하여 LOAD의 스위치를 이동시켜 220V의 전압이 조절할 수
                있도록 해준다.
            </h4>


            <img src="{{ site.baseurl }}/img/portfolio/portfolio3/IMG_portfolio3_13.jpg" style="max-width: 100%; height: auto;"><br>
            <h4><strong>[사진15] 완성된 스마트플러그</strong></h4>

            <h4>
                버튼을 클릭함으로써 안드로이드 기기가 아두이노로부터 Wifi 신호를 수신하여, 블루투스 신호로 스마트플러그로 전송해 전력을 ON/OFF 할 수 있는 스마트 플러그이다. [그림20]에서
                볼 수 있듯이 시중에서
                파는 제품 만큼 디자인이나, 세부적인 기능면에서는 많이 부족하지만 저렴한 가격의 모듈을 사용해 가성비가 높다는 점에서 차별성을 두었다. 스마트 플러그의 상용화를 위해서는 개정 규정을
                만족시키는 성능에 기반을
                둠은 물론이고, 감전 등 안전사양과 효율적인 이득을 위해 자체 소모 전력, 대기전력, 자동 차단 등 기능과 조화를 이룬 개발 방향이 중요하다. 본 논문에서는 시중에서 판매하는 제품의
                기본적인 기능밖에
                따라가지 못했지만, 조금 더 심도 있는 연구를 통해 좀더 세부적인 기능을 추가해보고, 좀 더 안전하고, 효율적인 스마트 플러그를 연구해볼 계획이다.
            </h4>
</div>