---
layout: post
title:  "2018-12-16 개발일기"
date:   2018-12-16
excerpt: "면접준비"
tag:
comments: true
---



# 2018 - 12 - 16 개발일기

### Spring Framework 관련 질문



#### **1. 스프링 프레임워크란?**

- 자바 앤터프라이즈 개발을 편리하게 해주는 경량급 오픈소스 애플리케이션 프레임워크
- POJO기반의 Enterprise Application 개발을 쉽고 편하게 할 수 있도록 한다.
- Java Application을 개발하는데 필요한 하부구조를 포괄적으로 제공하기때문에 개발자는 Application 개발에 집중할 수 있다.
- 대한민국 공공기간의 웹 서비스 개발시 사용을 권장하고 있는 전자 정부 표준 프레임워크의 기반 기술이다.



#### **2. Container란?**

- 컨테이너는 보통 instance의 Life Cycle을 관리하며, 생성된 인스턴스에게 추가적인 기능을 제공하도록 하는 것이다. 다시 말해, 컨테이너란 작성한 코드의 처리과정을 위임받은 독립적인 존재라고 생각하면 된다.

- 컨테이너는 적절한 설정만 되어있다면, 누구의 도움없이도 프로그래머가 작성한 코드를 스스로 참조한 뒤 알아서 객체의 생성과 소멸을 컨트롤 해준다.

#### **3. IOC란?**

- IoC(Inversion of Control)이란, 객체의 생성부터 Life Cycle 관리까지 모든 객체에 대한 제어권이 바뀐 것을 의미 합니다. 또는 제어권한이 다른 대상에게 위임하는 것입니다. (여기서 다른 대상은 Servlet과 같은  Bean을 관리해주는 container)
- 이 방식은 대부분의 프레임워크에서 사용하는 방법으로, 개발자는 필요한 부분을 개발해서 끼워넣기의 형태로 개발하고 실행하게 됩니다. 프레임워크가 이러한 구조를 가지기 때문에 개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식의 개발을 하게 된다.



#### **4. Framework와 Library의 차이?**

- IoC의 개념이 적용되었나의 차이
- 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다.
- 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다.



#### **5. DI (Dependency Injection)**


- **DI 란?**
  - Dependency Injection은 Spring Framework에서 지원하는 IoC의 형태이다.
  - DI는 클래스 사이의 의존관계를 Bean 설정 정보를 바탕으로 컨테이너가 자동적으로 연결해주는 것을 말한다. 개발자들은 제어를 담당할 필요없이 Bean 설정 파일에 의존관계가 필요하다는 정보만 추가해주면 된다. 
  - 컨테이너가 실행 흐름의 주체가 되어 Application 코드의 의존관계를 주입해주는 것
- **의존성이란**?

  - 현재 객체가 다른 객체와 상호작용하고 있다면 다른 객체들을 현재 객체의 의존이라 한다.
- **의존성이 위험한 이유**

  - 하나의 모듈이 바뀌면 의존하고 있는 다른 모듈까지 변경되어야 한다.
  - 테스트 가능한 어플을 만들 때 의존성이 있으면 유닛테스트 작성이 어렵다.
  - 유닛테스트의 목적 자체가 다른 모듈로부터 독립적으로 테스트하는 것을 요구한다.
- **DI의 특징**

  - 'new'를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참조하면 된다.
  - 의존성 주입은 IoC 개념을 바탕으로 한다. 클래스가 외부로부터 의존성을 가져야한다.
- **DI가 필요한 이유**

  - 클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할 수 있다.
  - 비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적
- **DI의 세가지 방법**

  - Contructor Injection : 생성자 삽입
  - Method(Setter) Injection: 메소드 매개 변수 삽입
  - Field injection : 맴버 변수 삽입

#### **6. AOP란 ? **

- Aspect Oriented Programming 관점 지향 프로그래밍의 약자

- 기존의 OOP에서 기능별로 class를 분리했음에도 불구하고, 여전히 로그, 트랜잭션, 자원해제, 성능테스트, 등 처럼 공통적으로 반복되는 중복코드 ( 횡단 관심사 ) 가 나오는 단점을 해결하고자 나온 방식 

- 개발코드에서는 비지니스 로직에 집중하고 실행시 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로써 중복 코드를 줄일 수 있는 방법

   

#### **7. POJO란?**

- 번역하면 '평범한 구식 자바 객체', 즉 Framework Interface나 class를 구현하거나 확장하지 않은 단순한 클래스.

- 특징

  - Java에서 제공하는 API 외에 종속되지 않음
  - 특정 규약, 환경에 종속되지 않음

- 환경에 종속되지 않는 것의 장점

  - 코드의 간결함 (비즈니스 로직과 특정 환경/Low 레벨 종속적인 코드를 분리하므로 단순)
  - 비즈니스 로직과 특정 환경이 분리되므로 단순함
  - 자동화 테스트에 유리 (환경 종속적인 코드는 자동화 테스트가 어렵지만, POJO는 테스트가 유연)


#### **8. DAO란?** 

- DB에 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 객체를 말한다.
- DB에 접근을 하기 위한 로직과 비즈니스 로직을 분리하기 위해서 사용한다.



#### **9. VO란?**

- 계층간 데이터 교환을 위한 자바빈즈를 말한다. 

  (여기서 말하는 계층은 Controller, View Business, Persistent Layer)

- 일반적인 VO는 로직을 가지고 있지 않은 순수한 데이터 객체이며, 속성과 그 속성에 접근하기 위한 getter, setter 메소드만 가진 클래스이다.
- DTO 라고도 불린다.



#### 10. JDBC란?

-   Java Data Base Connection의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있는 프로그래밍
- JDBC란 Java에서 DB와 연동하고 쓰기위해 사용하는 API이다.

#### **11. Mybatis란 ?**

- JDBC는 DB 연동에 필수적으로 사용하는 것인데 이 JDBC만 사용해서 DB 쿼리문을 작성하면 java소스와 쿼리소스가 겹치게 되고 관리가 어려워진다. Mybatis는 SQL 쿼리문을 xml 형식의 파일로 분리시켜 저장관리할 수 있고 java소스에서 xml 태그의 id만 호출하며 개발의 편리함을 제공한다. Mybatis는 xml형식의 쿼리파일을 저장 및 호출하는 역할을 내부적으로 처리하는 것이다.

- 객체, 데이터베이스, 매퍼 자체를 독립적으로 작성하고 DTO에 해당하는 부분과 SQL실행결과를 SQL문등에 매핑해서 사용할 수 있도록 지원.

- 스프링이나 JDBC를 통해 작업하던 dao에 관련된 작업은 모두 sql문이 자바 소스상에 위치했었으나 이제 sql문은 설정파일로 관리한다.

- 설정파일로 분리되면 변경되거나 했을때 설정파일만 건드리면 되므로 유지보수에 좋다. 또한, 매개변수나 리턴타입으로 매핑되는 모든 DTO에 관련된 부분도 모두 설정파일에서 작업한다.



#### **12. MVC 패턴에 대해 설명해보세요**



\- 객체지향프로그래밍에서, MVC란 사용자 인터페이스를 성공적이며 효과적으로 데이터 모형에 관련 시키기 위한 방법론 또는 설계 방식중 하나이다. MVC방식은 자바, Smalltalk,

\- MVC 패턴은 목적 코드의 재사용에 유용한 것은 물론, 사용자 인터페이스와 응용프로그램 개발에 소요되는 시간을 현저하게 줄여주는 형식이라고 많은 개발자들이 평가하고 있다.

**MVC 구성요소**

**Model** - 소프트웨어 응용과 그와 관련된 고급 클래스 내의 **논리적 데이터 기반 구조를 표****현**. 이 목적 모형은 사용자 인터페이스에 관한 어떠한 정보도 가지고 있지 않다.

**View** - 사용자 인터페이스 내의 구성요소들을 표현(**사용자에게 보여지는 화면**)

**Controller** - Model과 View를 연결하고 있는 클래스를 대표, **Model과 View 내의 클래스들 간 정보 교환**하는데 사용.

















#### **Spring MVC 처리 순서****

1. 클라이언트(Client)가 서버에 어떤 요청(Request)을 한다면 스프링에서 제공하는 **DispatcherServlet** 이라는 클래스(일종의 front controller)가 요청을 가로챈다. (web.xml에 살펴보면 모든 url ( / )에 서블릿 매핑을하여 모든 요청을 DispatcherServlet이 가로채게 해둠(변경 가능))

2. 요청을 가로챈 DispatcherServlet은 **HandlerMapping**(URL 분석등..)에게 어떤 컨트롤러에게 요청을 위임하면 좋을지 물어본다. (servlet-context.xml에서 @Controller로 등록한 것들을 스캔해서 찾아준다.)
3. 요청에 매핑된 컨트롤러가 있다면 @RequestMapping을 통하여 요청을 처리할 메서드에 도달한다.

4. 컨트롤러에서는 해당 요청을 처리할 Service를 주입(DI)받아 비즈니스로직을 Service에게 위임한다.

5. Service에서는 요청에 필요한 작업 대부분(코딩)을 담당하며 데이터베이스에 접근이 필요하면 DAO를 주입받아 DB처리는 DAO에게 위임한다.

6. DAO는 mybatis(또는 hibernate등) 설정을 이용해서 SQL 쿼리를 날려 DB의 정보를 받아 서비스에게 다시 돌려준다. (이 때 보통 VO(dto)를 컨트롤러에서 부터 내려받아 쿼리의 결과를 VO에 담는다. (mybatis의 resultType) 

7. 모든 로직을 끝낸 서비스가 결과를 컨트롤러에게 넘긴다.

8. 결과를 받은 컨트롤러는 Model객체에 결과물 어떤 view(jsp)파일을 보여줄 것인지등의 정보를 담아 DispatcherServlet에게 보낸다.

9. DispatcherServlet은 ViewResolver에게 받은 뷰의 대한 정보를 넘긴다.

10. ViewResolver는 해당 JSP를 찾아서(응답할 View를 찾음) DispatcherServlet에게 알려준다.

(servlet-context.xml에서 suffix, prefix를 통해 /WEB-INF/views/index.jsp 이렇게 만들어주는 것도 ViewResolver)

11. DispatcherServlet은 응답할 View에게 Render를 지시하고 View는 응답 로직을 처리한다.

12. 결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다.